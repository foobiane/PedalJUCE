#include <dirent.h>
#include <limits.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

bool is_header_file(char* name) {
    return strlen(name) >= 2 && !strncmp(name + strlen(name) - 2, ".h", 2);
}

// Constructs a dynamically-allocated array of file names in the specified directory, recursing to
// any subdirectories.
void recurse_directories(char* path, char*** filenames, int* num_files) {
    DIR* d = opendir(path);
    struct dirent *dir;

    printf("Recursing in path %s\n", path);
    if (!d) {
        fprintf(stderr, "Directory recursion failed for path %s\n", path);
        exit(1);
    }

    while ((dir = readdir(d))) {
        // Files: Add filename to array
        switch (dir->d_type) {
            case DT_REG: {
                if (!is_header_file(dir->d_name))
                    break;

                *num_files += 1;
                *filenames = realloc(*filenames, *num_files * sizeof(char*));

                (*filenames)[*num_files - 1] = strdup(path);
                (*filenames)[*num_files - 1] = realloc((*filenames)[*num_files - 1], strlen(path) + strlen(dir->d_name) + 2);
                strcat(strcat((*filenames)[*num_files - 1], "/"), dir->d_name);

                printf("Added %s to list of filenames\n", (*filenames)[*num_files - 1]);

                break;
            };
            
            // Directories: Recurse into them
            case DT_DIR: {
                if (!strcmp(dir->d_name, ".") || !strcmp(dir->d_name, "..") || !strcmp(dir->d_name, "IncludeScript"))
                    break;

                char* new_path = strdup(path);
                new_path = realloc(new_path, strlen(new_path) + strlen(dir->d_name) + 2);
                strcat(strcat(new_path, "/"), dir->d_name);

                recurse_directories(new_path, filenames, num_files);

                free(new_path);

                break;
            };

            // Other files: Ignore
            default:
                break;
        }
    }

    closedir(d);
}

// Creates the include file for custom pedals.
void construct_include_file(char** filenames, int num_files) {
    FILE* f = fopen("../../Source/PedalIncludes.h", "w+");

    if (f) {
        fprintf(f, "// This file was auto-generated by the include script in ../Pedals/IncludeScript.\n\n");
        fprintf(f, "#pragma once\n\n#include <JuceHeader.h>\n\n#include <memory>\n#include <stdexcept>\n#include <string>\n#include <vector>\n\n");

        fprintf(f, "#include \"Pedal.h\"\n");

        // Including all pedals
        for (int i = 0; i < num_files; i++)
            fprintf(f, "#include \"%s\"\n", filenames[i]);


        fprintf(f, "\nclass PedalJUCEAudioProcessorEditor; // forward declaration\n");

        fprintf(f, "\nconst std::vector<std::string> PEDAL_TYPES = {\"Default\"");

        // Creating a vector of imported pedals
        for (int i = 0; i < num_files; i++) {
            // The typename for the pedal should match the name of the file, excluding other path 
            // info and the extension.
            char* typename = strndup(strrchr(filenames[i], '/') + 1, (int) (strrchr(filenames[i], '.') - strrchr(filenames[i], '/')) - 1);
            fprintf(f, ", \"%s\"", typename);
            free(typename);
        }

        // Writing a function that allows us to create a pedal dynamically based on a string that 
        // specifies the type
        fprintf(f, "};\n\nstd::unique_ptr<Pedal> getPedalFromName(std::string name, PedalJUCEAudioProcessorEditor* e) {\n");
        fprintf(f, "\tif (name == \"Default\") { return std::make_unique<Pedal>(e); }\n");

        for (int i = 0; i < num_files; i++) {
            char* typename = strndup(strrchr(filenames[i], '/') + 1, (int) (strrchr(filenames[i], '.') - strrchr(filenames[i], '/')) - 1);
            fprintf(f, "\tif (name == \"%s\") { return std::make_unique<%s>(e); }\n", typename, typename);
            free(typename);
        }

        fprintf(f, "\telse { throw std::invalid_argument(\"Requested pedal does not exist\"); }\n}\n");

        fclose(f);
    }
} 

int main(void) {
    char** filenames = malloc(sizeof(char**));
    int num_files = 0;

    char init_path[PATH_MAX];
    realpath("../", init_path);

    recurse_directories(init_path, &filenames, &num_files);
    construct_include_file(filenames, num_files);

    // Cleanup
    for (int i = 0; i < num_files; i++)
        free(filenames[i]);

    free(filenames);
}